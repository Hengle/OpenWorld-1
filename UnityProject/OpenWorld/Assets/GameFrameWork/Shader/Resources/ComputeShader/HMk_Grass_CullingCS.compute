
#include "./../HLSLIncludes/Common/HMK_Struct.hlsl"


// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

//-------------------------------------------------------------
//        Constants
//----------------------------------------
#define THREAD_GROUP_SIZE_X 64
#define THREAD_GROUP_SIZE_Y 1
#define THREAD_GROUP_SIZE_Z 1

//--------------------
// Buffer
//-------------------
StructuredBuffer<GrassTRS> _AllInstancesGrassBuffer; //全部传入的草信息
RWStructuredBuffer<uint> _ArgsBuffer;
RWStructuredBuffer<uint> _IsVisibleBuffer;
RWStructuredBuffer<uint> _SortingData;

//----
//
//----
float4x4 _VPMatrix;
uint _StartOffset;//起始距离
float3 _LODDistance;//
float3 _CenterPos;//相机位置/玩家位置

inline uint IsVisibleAfterFrustumCulling(float4 positionCS)
{
    // absPosCS.z <= absPosCS.w &&
    // absPosCS.y <= absPosCS.w * 1.5 &&
    // absPosCS.x <= absPosCS.w * 1.1 &&
    // absPosCS.w <= _MaxDrawDistance)
    if (positionCS.z <= positionCS.w &&
    positionCS.y >= -positionCS.w * 1.3 &&
    positionCS.y <= positionCS.w * 1.3 &&
    positionCS.x >= -positionCS.w * 1.1 &&
    positionCS.x <= positionCS.w * 1.1 &&
    positionCS.w <= _LODDistance.z)
        return 1;

    return 0;


    // return(positionCS.z > positionCS.w
    // || positionCS.x < - positionCS.w
    // || positionCS.x > positionCS.w
    // || positionCS.y < - positionCS.w
    // || positionCS.y > positionCS.w)
    //     ? 0: 1;

}

inline uint CalcLOD(float3 positionWS, float3 centerPosWS)
{
    int lod = 0;
    float dist = distance(positionWS, _CenterPos);
    
    if (dist - _LODDistance.x < 0.01)
    {
        lod = 0;
    }
    else if (dist - _LODDistance.y < 0.01)
    {
        lod = 1;
    }
    else
    {
        lod = 2;
    }
    return lod;
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
void CSMain(uint3 id: SV_DispatchThreadID)
{
    int grassIndex = id.x + _StartOffset;
    GrassTRS trs = _AllInstancesGrassBuffer[grassIndex];
    float3 positionWS = trs.position;
    float4 absPosCS = abs(mul(_VPMatrix, float4(trs.position, 1.0)));

    uint isInFrustum = IsVisibleAfterFrustumCulling(absPosCS);//是否通过视锥剔除以及距离剔除

    uint isVisible = 1;

    isVisible *= isInFrustum;

    int lod = CalcLOD(positionWS, _CenterPos);

    uint argsIndex = 1;
    argsIndex += 5 * (lod > 0);
    argsIndex += 5 * (lod > 1);

    //output
    _IsVisibleBuffer[grassIndex] = isVisible;
    InterlockedAdd(_ArgsBuffer[argsIndex], isVisible);

    _SortingData[grassIndex] = grassIndex;
}
